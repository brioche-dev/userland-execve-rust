use elfloader::{ElfBinary, ElfLoader, ElfLoaderErr};
use nix::sys::mman::{mmap, mprotect, MapFlags, ProtFlags};
use std::ffi::c_void;
use std::num::NonZeroUsize;
use xmas_elf::header::HeaderPt2;

struct Loader {
    addr: *mut c_void,
}

fn flags_to_prot(flags: elfloader::Flags) -> nix::sys::mman::ProtFlags {
    let r = if flags.is_read() {
        ProtFlags::PROT_READ
    } else {
        ProtFlags::PROT_NONE
    };
    let w = if flags.is_write() {
        ProtFlags::PROT_WRITE
    } else {
        ProtFlags::PROT_NONE
    };
    let x = if flags.is_execute() {
        ProtFlags::PROT_EXEC
    } else {
        ProtFlags::PROT_NONE
    };
    r | w | x
}

impl ElfLoader for Loader {
    fn allocate(&mut self, load_headers: elfloader::LoadableHeaders) -> Result<(), ElfLoaderErr> {
        // Save the contents so we can iterate multiple times
        let load_headers = load_headers.collect::<Vec<_>>();

        // Compute the total size of the ELF loaded in memory
        let base = load_headers
            .iter()
            .map(|header| header.virtual_addr())
            .min()
            .unwrap();
        let end = load_headers
            .iter()
            .map(|header| header.virtual_addr() + header.mem_size())
            .max()
            .unwrap();
        let size = end - base;
        let size = NonZeroUsize::new(size.try_into().unwrap()).unwrap();

        // Allocate space for the ELF
        self.addr = unsafe {
            mmap(
                None,
                size,
                ProtFlags::PROT_NONE,
                MapFlags::MAP_SHARED | MapFlags::MAP_ANON,
                -1,
                0,
            )
        }
        .unwrap();

        // Fix the permissions of regions
        for header in load_headers {
            let vaddr = header.virtual_addr().try_into().unwrap();
            unsafe {
                mprotect(
                    self.addr.offset(vaddr),
                    header.mem_size().try_into().unwrap(),
                    flags_to_prot(header.flags()),
                )
            }
            .unwrap();
        }

        Ok(())
    }

    fn load(
        &mut self,
        _flags: elfloader::Flags,
        base: elfloader::VAddr,
        region: &[u8],
    ) -> Result<(), ElfLoaderErr> {
        let base = base.try_into().unwrap();
        unsafe {
            std::ptr::copy_nonoverlapping(
                region.as_ptr(),
                self.addr.offset(base) as *mut u8,
                region.len(),
            )
        }
        Ok(())
    }

    fn relocate(&mut self, entry: elfloader::RelocationEntry) -> Result<(), ElfLoaderErr> {
        let offset = entry.offset.try_into().unwrap();
        let addend = entry.addend.unwrap().try_into().unwrap();
        unsafe {
            let dst = self.addr.offset(offset);
            let src = self.addr.offset(addend);
            std::ptr::write(dst as *mut *const c_void, src)
        }
        Ok(())
    }
}

pub fn load(elf: &[u8]) -> ((usize, HeaderPt2), Option<(usize, usize)>) {
    let binary = ElfBinary::new(elf).unwrap();
    assert!(binary.is_pie());
    let opt_interp = binary
        .interpreter()
        .map(|interp| std::fs::read(interp).unwrap());
    let opt_interp = opt_interp
        .as_ref()
        .map(|interp| ElfBinary::new(interp).unwrap());
    let mut bin_loader = Loader {
        addr: std::ptr::null_mut(),
    };
    binary.load(&mut bin_loader).unwrap();
    let opt_interp = opt_interp.map(|interp| {
        let mut interp_loader = Loader {
            addr: std::ptr::null_mut(),
        };
        interp.load(&mut interp_loader).unwrap();
        (
            interp_loader.addr as usize,
            interp.file.header.pt2.entry_point().try_into().unwrap(),
        )
    });
    (
        (bin_loader.addr as usize, binary.file.header.pt2),
        opt_interp,
    )
}
