use goblin::{
    elf::{self, Elf},
    elf64::program_header::PT_LOAD,
};
use nix::{
    sys::mman::{mmap, MapFlags, ProtFlags},
    unistd::{sysconf, SysconfVar},
};
use std::{fs::File, num::NonZeroUsize, os::fd::AsRawFd, path::Path};

pub fn load(path: &Path) -> (usize, elf::Header, Option<(usize, elf::Header)>) {
    let file = File::open(path).unwrap();
    let bytes = std::fs::read(path).unwrap();
    let elf = Elf::parse(&bytes).unwrap();
    let opt_interp = match elf.interpreter {
        Some(interp) => match load(interp.as_ref()) {
            (interp_load_addr, interp_header, None) => Some((interp_load_addr, interp_header)),
            (_, _, Some(_)) => panic!(),
        },
        None => None,
    };
    let is_pie = elf
        .program_headers
        .iter()
        .find(|h| h.p_type == PT_LOAD)
        .unwrap()
        .p_vaddr
        == 0;
    assert!(is_pie);
    let total_size: usize = elf
        .program_headers
        .iter()
        .filter(|h| h.p_type == PT_LOAD)
        .map(|h| h.p_vaddr + h.p_memsz)
        .max()
        .unwrap()
        .try_into()
        .unwrap();
    let total_size = NonZeroUsize::new(total_size).unwrap();
    let base_ptr = unsafe {
        mmap(
            None,
            total_size,
            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE,
            MapFlags::MAP_PRIVATE | MapFlags::MAP_ANON,
            -1,
            0,
        )
    }
    .unwrap();
    let base_addr = base_ptr as usize;

    let page_size: usize = sysconf(SysconfVar::PAGE_SIZE)
        .unwrap()
        .unwrap()
        .try_into()
        .unwrap();
    for ph in elf.program_headers {
        if ph.p_type != PT_LOAD {
            continue;
        }
        assert!(ph.p_memsz >= ph.p_filesz);

        let size: usize = ph.p_memsz.try_into().unwrap();
        let size = NonZeroUsize::new(size).unwrap();
        let prot = (ph.p_flags >> 2) | ((ph.p_flags & 0b001) << 2) | (ph.p_flags & 0b010);
        let prot = prot.try_into().unwrap();
        let prot = ProtFlags::from_bits(prot).unwrap();
        let offset: usize = ph.p_offset.try_into().unwrap();
        let vaddr: usize = ph.p_vaddr.try_into().unwrap();
        let unaligned_addr = base_addr + vaddr;
        let addr = unaligned_addr / page_size * page_size;
        let align_dist = unaligned_addr - addr;
        let offset = offset - align_dist;
        let offset = offset.try_into().unwrap();
        let addr = NonZeroUsize::new(addr).unwrap();
        unsafe {
            mmap(
                Some(addr),
                size,
                prot,
                MapFlags::MAP_PRIVATE | MapFlags::MAP_FIXED,
                file.as_raw_fd(),
                offset,
            )
        }
        .unwrap();
    }

    (base_addr, elf.header, opt_interp)
}
