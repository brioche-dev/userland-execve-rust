use goblin::{
    elf::{self, Elf},
    elf64::program_header::PT_LOAD,
};
use nix::{
    sys::mman::{mmap, MapFlags, ProtFlags},
    unistd::{sysconf, SysconfVar},
};
use std::{fs::File, num::NonZeroUsize, os::fd::AsRawFd, path::Path, ptr};

pub fn load(path: &Path) -> (usize, elf::Header, Option<(usize, elf::Header)>) {
    let file = File::open(path).unwrap();
    let bytes = std::fs::read(path).unwrap();
    let elf = Elf::parse(&bytes).unwrap();
    let opt_interp = match elf.interpreter {
        Some(interp) => match load(interp.as_ref()) {
            (interp_load_addr, interp_header, None) => Some((interp_load_addr, interp_header)),
            (_, _, Some(_)) => panic!(),
        },
        None => None,
    };
    let is_pie = elf
        .program_headers
        .iter()
        .find(|h| h.p_type == PT_LOAD)
        .unwrap()
        .p_vaddr
        == 0;
    assert!(is_pie);
    let total_size: usize = elf
        .program_headers
        .iter()
        .filter(|h| h.p_type == PT_LOAD)
        .map(|h| h.p_vaddr + h.p_memsz)
        .max()
        .unwrap()
        .try_into()
        .unwrap();
    let total_size = NonZeroUsize::new(total_size).unwrap();
    let base_ptr = unsafe {
        mmap(
            None,
            total_size,
            ProtFlags::PROT_READ | ProtFlags::PROT_WRITE, // TODO: read only fix
            MapFlags::MAP_PRIVATE | MapFlags::MAP_ANON,
            -1,
            0,
        )
    }
    .unwrap();
    let base_addr = base_ptr as usize;

    let page_size: usize = sysconf(SysconfVar::PAGE_SIZE)
        .unwrap()
        .unwrap()
        .try_into()
        .unwrap();
    let page_round_down = |addr: usize| addr / page_size * page_size;
    let page_round_up = |addr: usize| (addr + (page_size - 1)) / page_size * page_size;
    for ph in elf.program_headers {
        if ph.p_type != PT_LOAD {
            continue;
        }
        assert!(ph.p_memsz >= ph.p_filesz);

        let size: usize = ph.p_filesz.try_into().unwrap();
        let prot = (ph.p_flags >> 2) | ((ph.p_flags & 0b001) << 2) | (ph.p_flags & 0b010);
        let prot = prot.try_into().unwrap();
        let prot = ProtFlags::from_bits(prot).unwrap();
        let offset: usize = ph.p_offset.try_into().unwrap();
        let vaddr: usize = ph.p_vaddr.try_into().unwrap();
        let unaligned_addr = base_addr + vaddr;
        let addr = page_round_down(unaligned_addr);
        let align_dist = unaligned_addr - addr;
        let size = size + align_dist;
        let size = NonZeroUsize::new(size).unwrap();
        let offset = offset - align_dist;
        let offset = offset.try_into().unwrap();
        let addr = NonZeroUsize::new(addr).unwrap();
        unsafe {
            mmap(
                Some(addr),
                size,
                prot | ProtFlags::PROT_WRITE, // TODO: read only fix
                MapFlags::MAP_PRIVATE | MapFlags::MAP_FIXED,
                file.as_raw_fd(),
                offset,
            )
        }
        .unwrap();
        let file_end_addr = addr.get() + size.get();
        unsafe {
            ptr::write_bytes(
                file_end_addr as *mut u8,
                0,
                page_round_up(file_end_addr) - file_end_addr,
            );
        }
    }

    (base_addr, elf.header, opt_interp)
}
