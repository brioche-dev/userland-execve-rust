use elfloader::{ElfBinary, ElfLoader, ElfLoaderErr};
use nix::sys::mman::{mmap, mprotect, MapFlags, ProtFlags};
use nix::unistd::{sysconf, SysconfVar};
use std::ffi::c_void;
use std::fs::File;
use std::num::NonZeroUsize;
use std::os::fd::AsRawFd;
use std::path::Path;

struct Loader<'a> {
    addr: *mut c_void,
    path: &'a Path,
}

fn flags_to_prot(flags: elfloader::Flags) -> nix::sys::mman::ProtFlags {
    let r = if flags.is_read() {
        ProtFlags::PROT_READ
    } else {
        ProtFlags::PROT_NONE
    };
    let w = if flags.is_write() {
        ProtFlags::PROT_WRITE
    } else {
        ProtFlags::PROT_NONE
    };
    let x = if flags.is_execute() {
        ProtFlags::PROT_EXEC
    } else {
        ProtFlags::PROT_NONE
    };
    r | w | x
}

impl<'a> ElfLoader for Loader<'a> {
    fn allocate(&mut self, load_headers: elfloader::LoadableHeaders) -> Result<(), ElfLoaderErr> {
        // Save the contents so we can iterate multiple times
        let load_headers = load_headers.collect::<Vec<_>>();

        // Compute the total size of the ELF loaded in memory
        let base = load_headers
            .iter()
            .map(|header| header.virtual_addr())
            .min()
            .unwrap();
        let end = load_headers
            .iter()
            .map(|header| header.virtual_addr() + header.mem_size())
            .max()
            .unwrap();
        let size = end - base;
        let size = NonZeroUsize::new(size.try_into().unwrap()).unwrap();

        // Map ELF into memory
        let file = File::open(self.path).unwrap();
        self.addr = unsafe {
            mmap(
                None,
                size,
                ProtFlags::PROT_NONE,
                MapFlags::MAP_SHARED,
                file.as_raw_fd(),
                0,
            )
        }
        .unwrap();

        // Fix the permissions of regions
        let page_size: usize = sysconf(SysconfVar::PAGE_SIZE)
            .unwrap()
            .unwrap()
            .try_into()
            .unwrap();
        for header in load_headers {
            let vaddr: usize = header.virtual_addr().try_into().unwrap();
            let size: usize = header.mem_size().try_into().unwrap();
            let start_addr = self.addr as usize + vaddr;
            let end_addr = start_addr + size;
            let start_addr = start_addr / page_size * page_size; // Align down to page
            let end_addr = (end_addr + page_size - 1) / page_size * page_size; // Align up to page
            let size = end_addr - start_addr;
            let flags = flags_to_prot(header.flags()) | ProtFlags::PROT_WRITE; // TODO: read-only pages
            unsafe { mprotect(start_addr as *mut c_void, size, flags) }.unwrap();
        }

        Ok(())
    }

    fn load(
        &mut self,
        _flags: elfloader::Flags,
        base: elfloader::VAddr,
        region: &[u8],
    ) -> Result<(), ElfLoaderErr> {
        let base = base.try_into().unwrap();
        unsafe {
            std::ptr::copy_nonoverlapping(
                region.as_ptr(),
                self.addr.offset(base) as *mut u8,
                region.len(),
            )
        }
        Ok(())
    }

    fn relocate(&mut self, entry: elfloader::RelocationEntry) -> Result<(), ElfLoaderErr> {
        let offset = entry.offset.try_into().unwrap();
        let addend = entry.addend.unwrap().try_into().unwrap();
        unsafe {
            let dst = self.addr.offset(offset);
            let src = self.addr.offset(addend);
            std::ptr::write(dst as *mut *const c_void, src)
        }
        Ok(())
    }
}

#[derive(Copy, Clone)]
pub struct LoadInfo {
    pub load_addr: usize,
    pub entry_point: u64,
    pub ph_count: u16,
    pub ph_entry_size: u16,
    pub ph_offset: u64,
}

impl LoadInfo {
    fn new(loader: Loader, bin: ElfBinary) -> Self {
        let h = bin.file.header.pt2;
        Self {
            load_addr: loader.addr as usize,
            entry_point: h.entry_point(),
            ph_count: h.ph_count(),
            ph_entry_size: h.ph_entry_size(),
            ph_offset: h.ph_offset(),
        }
    }
}

pub fn load(path: &Path) -> (LoadInfo, Option<LoadInfo>) {
    let binary = std::fs::read(path).unwrap();
    let binary = ElfBinary::new(&binary).unwrap();
    let opt_interp = binary
        .interpreter()
        .map(|interp| (interp, std::fs::read(interp).unwrap()));
    let opt_interp = opt_interp
        .as_ref()
        .map(|(path, interp)| (path, ElfBinary::new(interp).unwrap()));
    let mut bin_loader = Loader {
        addr: std::ptr::null_mut(),
        path,
    };
    binary.load(&mut bin_loader).unwrap();
    let opt_interp = opt_interp.map(|(path, interp)| {
        let mut interp_loader = Loader {
            addr: std::ptr::null_mut(),
            path: Path::new(path),
        };
        interp.load(&mut interp_loader).unwrap();
        LoadInfo::new(interp_loader, interp)
    });
    let binary = LoadInfo::new(bin_loader, binary);
    (binary, opt_interp)
}
